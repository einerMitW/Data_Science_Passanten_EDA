---
title: "Weiner_Passanten01"
output:
  pdf_document:
    latex_engine: xelatex
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
#Pdf Format Nachschlagewerk {r}:
#echo = FALSE /verhindert das der code Block im Pdf angezeigt wird.
#message=FALSE /Beim Knitten werden nun keine Meldungen oder Warnungen von diesem Chunk angezeigt.
#warning = FALSE /Warnungen wie Removed 3 rows containing missing values... von ggplot2 erscheinen nicht im PDF

# Globale Chunk-Optionen
library(knitr)

if (knitr::is_html_output()) {
  knitr::opts_chunk$set(
    dev       = "png",
    dpi       = 96,
    fig.retina= 2,
    fig.align = "center",
    fig.width = 8, fig.height = 5,
    out.width = "100%",
    message = FALSE, warning = FALSE
  )
} else {
  knitr::opts_chunk$set(
    dev       = "cairo_pdf",
    fig.align = "center",
    fig.width = 7, fig.height = 4.5,
    message = FALSE, warning = FALSE
  )
}
#Beispiel Doc String zur beschreibung aller der Funktionen
#' [Kurzer Titel der Funktion, z.B. Addiert zwei Zahlen]
#' @description
#' [Kurze Beschreibung, was die Funktion tut.]
#' @param param_name_1 [Beschreibung Parameter 1 (Typ, Zweck).]
#' @return
#' [Beschreibung des Rückgabewerts (Typ, Inhalt).]
```

```{r}
library(tidyverse)
library(readr)
library(broom)
library(gridExtra)
library(stats)
library(janitor)
library(skimr)
library(lubridate)
library(dplyr)
library(lubridate)
library(ggplot2)
library(fmsb)
```

```{r}
getwd()
#Globale Variablen
tage_vektor <- c("Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag", "Sonntag")
monat_vektor <- c("Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez" )
location_color = c("Kaiserstraße" = "#8D34D1", "Schönbornstraße" = "#D19534", "Spiegelstraße" = "#2EB865", "Gesamtsumme" = "#000000")
```

# Passanten in Würzburg

## Import und Datenbereinigung

zuerst importiert man die Daten und zeigt Sie an um zu überprüfen ob der import funktioniert hat.

```{r}
passanten_raw <- read_csv2("Datensatz/passanten_wuerzburg.csv")
passanten <- as_tibble(passanten_raw)

passanten <- passanten %>%
  select(Zeitstempel,Wetter,Temperatur,Passanten,'Location Name',GeoPunkt) %>%
  mutate(
    jahr = year(Zeitstempel),
    monat = month(Zeitstempel),
    woche = isoweek(Zeitstempel),
    tag = day(Zeitstempel),
    stunde = hour(Zeitstempel),
    wochentag = weekdays(Zeitstempel),
    tag_im_jahr = yday(Zeitstempel)
  ) %>%
  filter(jahr != 2023)
```

Nun besitzt man die Daten als Dataframe. Um mit ihnen sinvolle, descriptive oder weiterführend eine Explorative Datenanalyse durchzuführen sollten die Daten zuerst bereinigt werden. Als nächstes prüfen wir ob die Spalentnamen Aussagekräfig sind und ändern sie ab falls notwendig

```{r}
#Formatieren Spalten Namen
passanten <- clean_names(passanten)
```

Somit können wir nun leer Spalten entfernen und nachsehen wie vollständig die Daten sind.

```{r}
#Aufzählung der NA nach Spalte
colSums(is.na(passanten))
```

Zum Schluss erhalten wir eine übersicht über die Daten

```{r}
skim(passanten)
```

## Aufgabe 1

## Beschreibung der Daten

Der Datensatz besteht aus 26015 Zeile und 14 Spalten.Die in den Spalten aufgezeichneten werte sind:

```{r}
skim(passanten)
```

Die interessantest Variable ist hierbei die anzahl der Passanten. Dabei werden hir die anzahl der Passanten mit jewails eine Zeitstempel und weiteren Metadaten wie: Temperatur, Ort der Aufzeichnung und Koordinaten des Ortes Zeilenweise angegeben. Die Zeitstempel sind dabei Stündlich für jede der drei Messtationen angegeben.

```{r}
table(passanten$location_name)
```

Somit kann man davon ausgehen das die anzahl der Passanten der anzahl der Passanten entspricht die inerhalb einer Stunde durch die Messtation erfasst wurden. Die Metadaten dienen dann zur Interpretation der Hauptdaten.

### Erhebung

Die Daten stamen von zählstationen an verschiedenen Punken aus der Nürnberger Innenstadt. Mit hilfe von Laserschranken zählen diese die Anzahl der Passanten welche gerade die Messtation Queren. Durch das Messen mit meheren Laserschranken pro Messtation kann auch die Geh-Richtung des Passanten bestimmt werden. Zur konsistenz der Daten wird vermerkt: "Nach Herstellerangabe kann mit der verwendeten Technik bis zu einem Durchfluss von ca. 500 Personen pro Minute eine Zählgenauigkeit von 99% erreicht werden." vgl. Methodik_hystreet.com. Dabei ist zu beachten, dass eine Zählstation eine Straße bis Maximal 32m Breite abdecken kann. Die Erheber der daten versichern jedoch, dass "Bei den veröffentlichten Daten handelt es sich immer um die Passantenfrequenz der gesamten Straßenbreite (außer es ist explizit anders angegeben)."

### Standorte

```{r}
anzahl_messpunkte_df <- passanten %>%
  summarise(
    Anzahl_Locations = n_distinct(location_name),
    Anzahl_GeoPunkte = n_distinct(geo_punkt)
  )

werte_messpunkte_df <- passanten %>%
   summarise(
      Locations  = unique(location_name),
      Geo_Punkte  = unique(geo_punkt)
   )

anzahl_messpunkte_df
werte_messpunkte_df
```

Der Datenstatz enthält Koordinaten in der Spalte geo_punkt und die orte der Messtationen in der Spalte location_name. Wenn man sich anschaut wie of eine einzelner Standort vorkommt sieht man, dass es jewail 3 Einzelne Standorte gibt und dazu passend die 3 Standorte in Koordinatenform. Die Summen (Wie oft ein Einzelner eintrag vorkommt) ist ebenfalls gleich. Somit ist eine eindeutige zuordung der Standorte zu den Koordinaten möglich. Gleichzeit können wir sicher sein das keine Falschen Standorte oder Koordinaten vorliegen und das jeder Standort auch mit den Korrekten Korrdinaten versehen sind.Wenn man nun die Koordinaten auf einer Karte anzeigen Lässt erhält man folgendes Bild.

```{r bild-einfuegen, echo=FALSE, out.width="50%", fig.cap="Hier steht die Bildunterschrift."}
# echo=FALSE versteckt den R-Code im finalen Dokument
# out.width="50%" setzt die Breite
# fig.cap="..." fügt eine Unterschrift hinzu

knitr::include_graphics("Bilder/wuerzburg_stadtplan_messtationen.png")
```

Man kann sehen, das die Stationen direkt in der Innenstad stationiert sind. Dabei ist jede Station in der Nähe einer Sehenswürdigkeit bzw. Öffentlichen Gebäude. Die Messtation Schönbornstraße befindet sich nah an der Marienkapelle, die Messtation Spiegelstraße auf dem weg zum Hofgarten und die Messtation Kaiserstraße in der nähe zum Hauptbahnhof. Dabei sind alle diese Straßen Hauptverkehrsstraßen auf welchen man mit gleichmäsiger auslastung rechnen kann. Das Dreiecksmuster welche die Stationen Aufspannen bilden somit eine Art Transitstrecke zwischen: Hauptbahnhof -\> Hofgarten -\> Marienkapelle -\> Hauptbahnhof.

## Aufgabe 2

```{r}
#--- 1. Analyse aggregiert ---
# Funktion guppiert nach location_name und berechnet anschließend: passanten jahres Summe, erfasste Tage im Datensatz, durchschnitt pro Monat, durchsnitt pro Tag und durchschnitt pro Stunde.
# Eingabe: df passanten
# Ausgabe: aggregiert_jahressumme_pro_location
aggregiert_jahressume_pro_location <- passanten %>%
  group_by(location_name) %>%
  summarise(
    
    # 1. Jahressumme pro Standort
    passanten_jahr_summe = sum(passanten, na.rm = TRUE),
    
    anzahl_tage_erfasst = n_distinct(as.Date(zeitstempel)),
    
    # 2. Mittelwert pro Monat
    durchschnitt_pro_monat = passanten_jahr_summe / 12,
    
    # 3. Mittelwert pro Woche
    durchschnitt_pro_woche = passanten_jahr_summe / (anzahl_tage_erfasst / 7),

    # 4. Mittelwert pro Tag
    durchschnitt_pro_tag = passanten_jahr_summe / anzahl_tage_erfasst,
    
    # Mittelwert pro Stunde
    durchschnitt_pro_stunde = mean(passanten, na.rm = TRUE)
  )

# --- 2. Analyse aggregiert (insgesamt) ---
# Funktion berechnet die Jahressumme aller passenten um damit den Mittelwert über alle Stationen zu berechnen
# Eingabe: df passanten
# Ausgabe: passanten_insgesamt
passanten_insgesamt <- passanten %>%
  summarise(
    
    # 1. Jahressumme (Gesamt)
    passanten_jahr_summe = sum(passanten, na.rm = TRUE),
    
    # Hilfsberechnung: Anzahl der einzigartigen Tage im gesamten Datensatz
    anzahl_tage_erfasst = n_distinct(as.Date(zeitstempel)),

    # 2. Mittelwert pro Monat (Gesamt)
    durchschnitt_pro_monat = passanten_jahr_summe / 12,
    
    # 3. Mittelwert pro Woche (Gesamt)
    durchschnitt_pro_woche = passanten_jahr_summe / (anzahl_tage_erfasst / 7),
    
    # 4. Mittelwert pro Tag (Gesamt)
    durchschnitt_pro_tag = passanten_jahr_summe / anzahl_tage_erfasst,
    
    # 5. Mittelwert pro Stunde (Gesamt)
    durchschnitt_pro_stunde = mean(passanten, na.rm = TRUE)
  )

aggregiert_jahressume_pro_location
passanten_insgesamt
```

## Aufgabe 3

```{r}
#' [Monatssumme über das Jahr]
#' @description
#' [Die Funktion Berechnet die Monatsumme der Passaten, gruppiert nach der location_name pro jahr]
#'
#' @param passanten df
#'
#' @return
#' [Rückgabewert ist ein der df sume_monat. Das wide Format zeigt die Daten sortiert nach monat und Location sowie gesamtsumme an]
#'
summe_monat <- passanten %>%
   group_by(location_name, monat) %>%
   summarise(monatssumme = sum(passanten)) %>%
   ungroup() %>%
   #Vertauschen der Zeilen und Spalten
   pivot_wider(names_from = location_name,
               values_from = monatssumme)%>%
   mutate(Gesamtsumme = rowSums(across(where(is.numeric)), na.rm = TRUE)) %>%
   arrange(monat)

summe_monat

#' [long plot format wandlung]
#' @description
#' [Formt den df summe_monat in ein long Format um]
#'
#' @param summe_monat 
#'
#' @return
#' [Gib den df summe_monat_plot in einem long Format aus welches zur Graphischen Darstellung verwendet werden kann]
mittelwert_monat_plot <- summe_monat %>% 
   pivot_longer(cols = -monat,
                names_to = "location_name",
                values_to = "gesamtsumme")
```

```{r}
ggplot(data = mittelwert_monat_plot, aes(x = monat, y = gesamtsumme, color = location_name)) +
  geom_line(linewidth = 1) +  # Zeichnet die Linien
  geom_point() +              # Fügt die Datenpunkte hinzu 
   scale_color_manual(values = location_color)+
  scale_x_continuous(breaks = 1:12, labels = monat_vektor)+

  # Titel und Achsenbeschriftungen
  labs(title = "Summen pro Monat und Straße",
       x = "Monat",
       y = "Summe",
       color = "Standort")
```

## Aufgabe 4

```{r}
tagessumme <- passanten %>% 
   mutate(
      Datum = as_date(zeitstempel)
   ) %>%
   group_by(Datum, wochentag, location_name) %>%
   summarise(
    Tagessumme = sum(passanten, na.rm = TRUE)
    ) %>%
   ungroup()






gesamttagessumme <- passanten %>% 
   mutate(
      Datum = as_date(zeitstempel)
   ) %>%
   group_by(Datum, wochentag) %>%
   summarise(
    Tagessumme_Gesamt = sum(passanten, na.rm = TRUE), 
    .groups = 'drop' )

#' [durschnitt tageswert]
#' @description
#' [die Funktion gruppiert nach wochentag und location und berechnet dann den durchschnitt. gleichzeitig sortiert sie die wochentage in der korrenkten wöchentlichen anordungn]
#' @param tagessumme
#' @return
#' [df durchnittlicher_tageswert der Passanten pro Messtation und Wochentag in long format]
durchschnittlicher_tageswert_gesamt <- gesamttagessumme %>%
   mutate(
    wochentag = factor(wochentag, levels = tage_vektor)
   )%>%
   group_by(wochentag)%>%
   summarise(
      durchschnitt_gesamt = mean(Tagessumme_Gesamt)
   )%>%
   ungroup()
durchschnittlicher_tageswert_gesamt









#' [durschnitt tageswert]
#' @description
#' [die Funktion gruppiert nach wochentag und location und berechnet dann den durchschnitt. gleichzeitig sortiert sie die wochentage in der korrenkten wöchentlichen anordungn]
#'
#' @param tagessumme
#' @return
#' [df durchnittlicher_tageswert der Passanten pro Messtation und Wochentag in long format]
durchschnittlicher_tageswert_location_plot <- tagessumme %>%
   mutate(
    wochentag = factor(wochentag, levels = tage_vektor)
   )%>%
   group_by(wochentag, location_name)%>%
   summarise(
      durchschnitt_tag = mean(Tagessumme)
   )%>%
   ungroup()
durchschnittlicher_tageswert_location_plot

#' [df in Tabellenformat ]
#' @description
#' [Formatiert einen df in eine Aussagekräftige Tabelle]
#'
#' @param durschnittlicher_tageswert_plot]
#' @return
#' []
durchschnittlicher_tageswert_location_wide <- durchschnittlicher_tageswert_location_plot %>%
   pivot_wider(
      names_from = location_name,
      values_from = durchschnitt_tag
   )%>% left_join(durchschnittlicher_tageswert_gesamt, 
    by = "wochentag")
durchschnittlicher_tageswert_location_wide
```

```{r}
# 1. Nimm deinen "Gesamt"-DF (Bild 2)
df_gesamt_prepared <- durchschnittlicher_tageswert_gesamt_plot %>%
  
  # 2. UMBENENNEN: Die Wert-Spalte muss identisch heißen
  rename(durchschnitt_tag = durchschnitt_gesamt) %>%
  
  # 3. HINZUFÜGEN: Die "Gruppen"-Spalte für die Legende
  mutate(location_name = "Gesamtdurchschnitt")


df_combined_long_plot <- bind_rows(
  durchschnittlicher_tageswert_location_plot, # Deine 21 Zeilen
  df_gesamt_prepared                          # Deine 7 vorbereiteten Zeilen
) %>%
  # WICHTIG: Stelle sicher, dass die Sortierung (Faktor) erhalten bleibt
  mutate(
    wochentag = factor(wochentag, levels = tage_vektor)
  )
df_combined_long_plot

ggplot(
  data = df_combined_long_plot, 
  aes(x = wochentag, y = durchschnitt_tag, fill = location_name)
) +
  
  # HIER IST DER SCHLÜSSEL: geom_col() mit position = "dodge"
  geom_col(position = "dodge") + 
  
  # Füge deine 4 Custom-Farben hinzu
  scale_fill_manual(values = location_color) +
  
  labs(
    title = "Aufgabe 4: Durchschnittl. Tageswert (Gegliedert & Gesamt)",
    subtitle = "Als gruppiertes Balkendiagramm",
    x = "Wochentag",
    y = "Durchschnittlicher Tageswert",
    fill = "Messstelle / Aggregat"
  )




ggplot() +
   #1. Plot
   geom_col(data = durchschnittlicher_tageswert_location_plot,
            aes(x = wochentag, y = durchschnitt_tag, fill = location_name)) +
   scale_fill_manual(values = location_color) +
   
   # 2. Plot
   geom_point(data = durchschnittlicher_tageswert_location_plot,
              aes(x = wochentag, y = durchschnitt_tag, color = location_name)) +
   
   labs(title = "Aufgabe 4: Durchschnittl. Tageswert pro Wochentag (Gestapelt)",
        x = "Wochentag",
        y = "Durchschnittl. Passanten",
        fill = "Messtellen")

```

## Aufgabe 5

```{r}
#'[Stündl. Mittelwert (Gegliedert)]
#' @description
#' Berechnet den durchschnittlichen Passantenwert für jede Stunde (0-23)
#' und für jede einzelne Messstelle ('location_name').
#' @param passanten [DataFrame] Das Roh-DataFrame 'passanten'.
#'   Benötigt die Spalten 'stunde', 'location_name' und 'passanten'.
#' @return
#' [DataFrame] 'passantenanzahl_stunden_plot' (langes Format).
#'   Enthält 72 Zeilen (24h * 3 Messstellen) mit dem stündlichen Mittelwert.
passantenanzahl_stunden_plot <- passanten %>%
   group_by(stunde, location_name) %>%
   summarise(
      passantenanzahl = mean(passanten)
      )%>%
   ungroup()



#' [Stündl. Mittelwert (Summiert)]
#' @description
#' Berechnet den durchschnittlichen Passantenwert für jede Stunde (0-23)
#' über ALLE Messstellen hinweg (Gesamtdurchschnitt).
#' @param passanten [DataFrame] Das Roh-DataFrame 'passanten'.
#'   Benötigt die Spalten 'stunde' und 'passanten'.
#' @return
#' [DataFrame] 'avg_stunde_gesamt' (langes Format).
#'   Enthält 24 Zeilen (eine pro Stunde) mit dem Gesamt-Stundenmittelwert.
avg_stunde_gesamt <- passanten %>%
   group_by(stunde) %>%
   summarise(
      durchschnitt_passanten_gesamt = mean(passanten, na.rm = TRUE)
   )%>%
   ungroup()


#' [Stündl. Mittelwert (Breites Format)]
#' @description
#' Wandelt das "lange" Plot-Format in ein "breites" Tabellen-Format um.
#' Jede Messstelle wird zu einer eigenen Spalte.
#' @param passantenanzahl_stunden_plot [DataFrame] Das "lange" Ergebnis aus Block 1.
#' @return
#' [DataFrame] 'passantenanzahl_stunden_wide'.
#'   Enthält 24 Zeilen (eine pro Stunde) und Spalten für jede Messstelle.   
passantenanzahl_stunden_wide <- passantenanzahl_stunden_plot %>%
   pivot_wider(
      names_from = location_name,
      values_from = passantenanzahl
      )%>%
   left_join(avg_stunde_gesamt, by = "stunde")
passantenanzahl_stunden_wide

```

```{r}

ggplot(data = passantenanzahl_stunden_plot, aes(x = stunde, y = passantenanzahl, color = location_name)) +
   # 1. Plot
  geom_line(linewidth = 1) +  # Zeichnet die Linien
  geom_point() +              # Fügt die Datenpunkte hinzu 
   scale_color_manual(values = location_color)+

   # 2. Plot
  geom_line(
    data = avg_stunde_gesamt, 
    aes(x = stunde, y = durchschnitt_passanten_gesamt, color = NULL),
    color = "black",
    linewidth = 1.5,
    color = "Gesamtdurchschnitt"
  ) + 
   
   scale_x_continuous(breaks = seq(0, 23, by = 2))
   
  labs(title = "Aufgabe 5: Durchschnittlicher Tagesverlauf (Gegliedert & Gesamt)",
       x = "Uhrzeit (Stunde des Tages)",
       y = "Durchschnittliche Passanten pro Stunde",
       color = "Standort")
```

# Literatur

<https://studyflix.de/statistik/mittelwert-6133>
